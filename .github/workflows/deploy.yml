name: Deploy RandomCorp to LKE

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force rebuild all images'
        required: false
        default: 'false'
        type: boolean

env:
  REGISTRY: docker.io
  API_IMAGE_NAME: johnhebeler/randomcorp
  FRONTEND_IMAGE_NAME: johnhebeler/randomcorp-frontend
  CLUSTER_NAME: randomcorp-lke
  DOMAIN: randomcorp.local

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Extract metadata for API
      id: meta-api
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.API_IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Extract metadata for Frontend
      id: meta-frontend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push API image
      uses: docker/build-push-action@v5
      with:
        context: ./api
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta-api.outputs.tags }}
        labels: ${{ steps.meta-api.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Build and push Frontend image
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta-frontend.outputs.tags }}
        labels: ${{ steps.meta-frontend.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Set up Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.6.0
        terraform_wrapper: false  # Allows capturing raw output

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'

    - name: Install Flux CLI
      run: |
        curl -s https://fluxcd.io/install.sh | sudo bash

    - name: Configure Terraform backend and variables
      run: |
        cd infra/terraform
        
        # Create terraform.tfvars file
        cat > terraform.tfvars << EOF
        linode_token = "${{ secrets.LINODE_TOKEN }}"
        cluster_name = "${{ env.CLUSTER_NAME }}"
        region = "us-central"
        k8s_version = "1.33"
        node_type = "g6-standard-2"
        node_count = 3
        autoscaler_min = 3
        autoscaler_max = 10
        enable_high_memory_pool = false
        tags = ["randomcorp", "production", "lke", "github-actions"]
        environment = "production"
        kubeconfig_path = "./kubeconfig.yaml"
        create_namespace = false
        EOF
        
        echo "âœ… Terraform variables configured"

    - name: Cache Terraform state
      uses: actions/cache@v3
      with:
        path: infra/terraform/terraform.tfstate*
        key: terraform-state-${{ env.CLUSTER_NAME }}-${{ github.ref_name }}
        restore-keys: |
          terraform-state-${{ env.CLUSTER_NAME }}-

    - name: Initialize Terraform
      run: |
        cd infra/terraform
        terraform init
        echo "âœ… Terraform initialized"

    - name: Validate Terraform configuration
      run: |
        cd infra/terraform
        terraform validate
        echo "âœ… Terraform configuration is valid"

    - name: Plan Terraform changes
      run: |
        cd infra/terraform
        terraform plan -out=tfplan -detailed-exitcode
        PLAN_EXIT_CODE=$?
        
        if [ $PLAN_EXIT_CODE -eq 0 ]; then
          echo "No changes needed"
          echo "TERRAFORM_CHANGES=false" >> $GITHUB_ENV
          echo "::notice title=Terraform Plan::No infrastructure changes required"
        elif [ $PLAN_EXIT_CODE -eq 2 ]; then
          echo "Changes detected, will apply"
          echo "TERRAFORM_CHANGES=true" >> $GITHUB_ENV
          echo "::notice title=Terraform Plan::Infrastructure changes detected and will be applied"
          
          # Show plan summary
          echo "ðŸ“‹ Terraform Plan Summary:"
          terraform show -no-color tfplan | head -50
        else
          echo "Terraform plan failed"
          echo "::error title=Terraform Plan Failed::The terraform plan command failed with exit code $PLAN_EXIT_CODE"
          exit 1
        fi
        
        echo "âœ… Terraform plan completed"

    - name: Apply Terraform changes
      id: terraform-apply
      run: |
        cd infra/terraform
        
        if [ "$TERRAFORM_CHANGES" = "true" ]; then
          echo "ðŸš€ Applying Terraform changes..."
          terraform apply -auto-approve tfplan
        else
          echo "ðŸ“‹ No Terraform changes to apply"
          # Still need to refresh to get outputs
          terraform refresh
        fi
        
        # Get outputs and set as GitHub Actions outputs
        CLUSTER_ID=$(terraform output -raw cluster_id)
        CLUSTER_STATUS=$(terraform output -raw cluster_status)
        CLUSTER_REGION=$(terraform output -raw cluster_region)
        KUBECONFIG_PATH=$(terraform output -raw kubeconfig_path)
        
        echo "CLUSTER_ID=$CLUSTER_ID" >> $GITHUB_ENV
        echo "cluster_id=$CLUSTER_ID" >> $GITHUB_OUTPUT
        echo "cluster_status=$CLUSTER_STATUS" >> $GITHUB_OUTPUT
        echo "cluster_region=$CLUSTER_REGION" >> $GITHUB_OUTPUT
        echo "kubeconfig_path=$KUBECONFIG_PATH" >> $GITHUB_OUTPUT
        
        echo "ðŸ“‹ Cluster ID: $CLUSTER_ID"
        echo "ðŸ“‹ Cluster Status: $CLUSTER_STATUS"
        echo "ðŸ“‹ Cluster Region: $CLUSTER_REGION"
        
        # Wait for cluster to be ready if it's not already
        if [ "$CLUSTER_STATUS" != "ready" ]; then
          echo "â³ Waiting for cluster to be ready..."
          for i in {1..20}; do
            terraform refresh > /dev/null 2>&1
            CURRENT_STATUS=$(terraform output -raw cluster_status)
            
            if [ "$CURRENT_STATUS" = "ready" ]; then
              echo "âœ… Cluster is ready!"
              echo "cluster_status=ready" >> $GITHUB_OUTPUT
              break
            fi
            
            echo "ðŸ”„ Cluster status: $CURRENT_STATUS, waiting... (attempt $i/20)"
            sleep 30
          done
        fi
        
        echo "âœ… LKE cluster deployed/updated via Terraform"

    - name: Configure kubectl with Terraform-generated kubeconfig
      run: |
        cd infra/terraform
        
        # Verify kubeconfig was created
        if [ ! -f "kubeconfig.yaml" ]; then
          echo "âŒ Kubeconfig file not found"
          exit 1
        fi
        
        # Copy kubeconfig and set permissions
        cp kubeconfig.yaml ../../kubeconfig.yaml
        chmod 600 ../../kubeconfig.yaml
        
        export KUBECONFIG=$(pwd)/../../kubeconfig.yaml
        echo "KUBECONFIG=$(pwd)/../../kubeconfig.yaml" >> $GITHUB_ENV
        
        # Test connection with retry logic
        echo "ðŸ”— Testing kubectl connection..."
        for i in {1..10}; do
          if kubectl cluster-info > /dev/null 2>&1; then
            echo "âœ… kubectl connection successful"
            kubectl cluster-info
            kubectl get nodes
            break
          fi
          echo "â³ Waiting for cluster API to be available... (attempt $i/10)"
          sleep 15
        done
        
        echo "âœ… kubectl configured with Terraform-generated kubeconfig"

    - name: Install NGINX Ingress Controller
      run: |
        echo "ðŸ”§ Installing NGINX Ingress Controller..."
        kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.1/deploy/static/provider/cloud/deploy.yaml
        
        # Wait for ingress controller to be ready
        kubectl wait --namespace ingress-nginx \
          --for=condition=ready pod \
          --selector=app.kubernetes.io/component=controller \
          --timeout=300s

    - name: Check if Flux is installed
      id: check-flux
      run: |
        if kubectl get namespace flux-system > /dev/null 2>&1; then
          echo "flux_installed=true" >> $GITHUB_OUTPUT
          echo "âœ… Flux is already installed"
        else
          echo "flux_installed=false" >> $GITHUB_OUTPUT
          echo "âŒ Flux is not installed"
        fi

    - name: Bootstrap Flux CD
      if: steps.check-flux.outputs.flux_installed == 'false'
      run: |
        echo "ðŸ”§ Bootstrapping Flux CD..."
        flux bootstrap github \
          --owner=GitRebeler \
          --repository=RandomCorp \
          --branch=master \
          --path=clusters/linode-lke \
          --personal \
          --token-auth

    - name: Update Helm values with current image tags
      run: |
        echo "ðŸ”„ Updating Helm values with new image tags..."
        
        # Get the latest image tags that were just built
        API_TAG=$(echo '${{ steps.meta-api.outputs.tags }}' | head -n1 | cut -d':' -f2)
        FRONTEND_TAG=$(echo '${{ steps.meta-frontend.outputs.tags }}' | head -n1 | cut -d':' -f2)
        
        echo "API Tag: $API_TAG"
        echo "Frontend Tag: $FRONTEND_TAG"
        
        # Update values.yaml
        sed -i "s|tag: \".*\"|tag: \"$API_TAG\"|g" helm-charts/randomcorp/values.yaml
        sed -i "/frontend:/,/service:/ s|tag: \".*\"|tag: \"$FRONTEND_TAG\"|" helm-charts/randomcorp/values.yaml

    - name: Commit and push updated values
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        if git diff --quiet; then
          echo "No changes to commit"
        else
          git add helm-charts/randomcorp/values.yaml
          git commit -m "Update image tags to ${{ github.sha }}"
          git push
        fi

    - name: Wait for Flux to deploy changes
      run: |
        echo "â³ Waiting for Flux to reconcile and deploy changes..."
        sleep 60
        
        # Check if HelmRelease exists and is ready
        kubectl wait --for=condition=Ready helmrelease/randomcorp \
          --namespace=default \
          --timeout=600s || true

    - name: Get ingress IP
      id: get-ip
      run: |
        echo "ðŸ“¡ Getting ingress LoadBalancer IP..."
        
        # Wait for LoadBalancer to get an external IP
        for i in {1..30}; do
          INGRESS_IP=$(kubectl get service ingress-nginx-controller \
            -n ingress-nginx \
            -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          
          if [ -n "$INGRESS_IP" ] && [ "$INGRESS_IP" != "null" ]; then
            echo "âœ… Ingress IP: $INGRESS_IP"
            echo "ingress_ip=$INGRESS_IP" >> $GITHUB_OUTPUT
            break
          fi
          
          echo "â³ Waiting for LoadBalancer IP... (attempt $i/30)"
          sleep 10
        done
        
        if [ -z "$INGRESS_IP" ] || [ "$INGRESS_IP" = "null" ]; then
          echo "âŒ Failed to get ingress IP"
          exit 1
        fi

    - name: Verify deployment
      run: |
        echo "ðŸ” Verifying deployment..."
        
        # Check pods
        kubectl get pods -l app.kubernetes.io/name=randomcorp
        kubectl get pods -l app.kubernetes.io/component=frontend
        
        # Check services
        kubectl get services
        
        # Check ingress
        kubectl get ingress
        
        # Test API health endpoint
        INGRESS_IP="${{ steps.get-ip.outputs.ingress_ip }}"
        echo "ðŸ¥ Testing API health endpoint..."
        
        for i in {1..10}; do
          if curl -f "http://$INGRESS_IP/api/health" > /dev/null 2>&1; then
            echo "âœ… API health check passed"
            break
          fi
          echo "â³ Waiting for API to be ready... (attempt $i/10)"
          sleep 30
        done

    - name: Display deployment info
      run: |
        INGRESS_IP="${{ steps.get-ip.outputs.ingress_ip }}"
        
        echo "ðŸŽ‰ Deployment Complete!"
        echo "========================"
        echo "ðŸ“‹ Access Information:"
        echo "  Ingress IP: $INGRESS_IP"
        echo "  Domain: ${{ env.DOMAIN }}"
        echo ""
        echo "ðŸŒ Application URLs:"
        echo "  Frontend: http://${{ env.DOMAIN }}/"
        echo " -or- "
        echo "  Frontend: http://$INGRESS_IP/"
        echo "  API: http://${{ env.DOMAIN }}/api/"
        echo "  API Docs: http://${{ env.DOMAIN }}/api/docs"
        echo ""
        echo "ðŸ“ Add this to your hosts file:"
        echo "   $INGRESS_IP ${{ env.DOMAIN }}"
        echo ""
        echo "âœ… RandomCorp is now running!"

    - name: Create deployment summary
      run: |
        INGRESS_IP="${{ steps.get-ip.outputs.ingress_ip }}"
        
        cat >> $GITHUB_STEP_SUMMARY << EOF
        # ðŸŽ‰ RandomCorp Deployment Successful!
        
        ## ðŸŒ Access Information
        - **Ingress IP**: \`$INGRESS_IP\`
        - **Domain**: \`${{ env.DOMAIN }}\`
        
        ## ðŸ”— Application URLs
        - [Frontend](http://${{ env.DOMAIN }}/)
        - [API](http://${{ env.DOMAIN }}/api/)
        - [API Documentation](http://${{ env.DOMAIN }}/api/docs)
        
        ## ðŸ—ï¸ Infrastructure Details (Terraform)
        - **Cluster ID**: \`${{ steps.terraform-apply.outputs.cluster_id }}\`
        - **Cluster Status**: \`${{ steps.terraform-apply.outputs.cluster_status }}\`
        - **Cluster Region**: \`${{ steps.terraform-apply.outputs.cluster_region }}\`
        - **Deployment Method**: Terraform (Infrastructure as Code)
        
        ## ðŸ“ Local Access Setup
        Add this line to your hosts file:
        \`\`\`
        $INGRESS_IP ${{ env.DOMAIN }}
        \`\`\`
        
        **Hosts file locations:**
        - Windows: \`C:\\Windows\\System32\\drivers\\etc\\hosts\`
        - Linux/Mac: \`/etc/hosts\`
        
        ## ðŸ“Š Deployment Details
        - **Cluster**: ${{ env.CLUSTER_NAME }}
        - **API Image**: ${{ env.REGISTRY }}/${{ env.API_IMAGE_NAME }}:latest
        - **Frontend Image**: ${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}:latest
        - **Commit**: ${{ github.sha }}
        - **Infrastructure**: Managed by Terraform
        EOF
